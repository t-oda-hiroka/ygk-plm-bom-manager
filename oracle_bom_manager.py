#!/usr/bin/env python3
"""
Oracle DBÁõ¥Êé•ÂèÇÁÖßBOMÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†
„É™„Éº„Éâ„Ç™„É≥„É™„Éº„É¢„Éº„Éâ„ÅßOracleÂÆü„Éá„Éº„Çø„ÇíÂèÇÁÖß
"""

import cx_Oracle
import sqlite3
import json
from typing import List, Dict, Any, Optional
from datetime import datetime
import os


class OracleBOMManager:
    """Oracle DBÁõ¥Êé•ÂèÇÁÖßBOMÁÆ°ÁêÜ„ÇØ„É©„ÇπÔºà„É™„Éº„Éâ„Ç™„É≥„É™„ÉºÔºâ"""
    
    def __init__(self, oracle_config=None, fallback_db_path="bom_database_dev.db"):
        """
        Oracle DBÁõ¥Êé•ÂèÇÁÖßBOMÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÇíÂàùÊúüÂåñ
        
        Args:
            oracle_config: OracleÊé•Á∂öË®≠ÂÆöËæûÊõ∏
            fallback_db_path: „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®SQLite„Éá„Éº„Çø„Éô„Éº„Çπ„Éë„Çπ
        """
        self.fallback_db_path = fallback_db_path
        self.db_path = fallback_db_path  # ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅ
        self.oracle_config = oracle_config or {
            'host': 'hrk-ora-db.cvqkhcprwraj.ap-northeast-1.rds.amazonaws.com',
            'port': 1521,
            'service_name': 'orcl',
            'username': 'ygk_pcs',
            'password': 'ygkpcs'
        }
        
        # OracleÊé•Á∂ö„ÉÜ„Çπ„Éà
        self.oracle_available = self._test_oracle_connection()
        
        print(f"üåê Oracle DBÊé•Á∂ö: {'‚úÖ Âà©Áî®ÂèØËÉΩ' if self.oracle_available else '‚ùå ‰ΩøÁî®‰∏çÂèØ („Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„É¢„Éº„Éâ)'}")
    
    def _test_oracle_connection(self) -> bool:
        """Oracle DBÊé•Á∂ö„ÉÜ„Çπ„Éà"""
        try:
            # Oracle Instant Client„É©„Ç§„Éñ„É©„É™„Éë„Çπ„ÇíÊòéÁ§∫ÁöÑ„Å´ÊåáÂÆö
            try:
                cx_Oracle.init_oracle_client(lib_dir="/usr/local/lib")
            except Exception as e:
                if "has already been initialized" not in str(e):
                    print(f"‚ö†Ô∏è  Oracle ClientÂàùÊúüÂåñË≠¶Âëä: {e}")
            
            dsn = f"{self.oracle_config['host']}:{self.oracle_config['port']}/{self.oracle_config['service_name']}"
            connection = cx_Oracle.connect(
                self.oracle_config['username'], 
                self.oracle_config['password'], 
                dsn
            )
            connection.close()
            return True
        except Exception as e:
            print(f"OracleÊé•Á∂ö„ÉÜ„Çπ„ÉàÂ§±Êïó: {e}")
            return False
    
    def _get_oracle_connection(self):
        """Oracle DBÊé•Á∂ö„ÇíÂèñÂæó"""
        if not self.oracle_available:
            raise Exception("Oracle DBÊé•Á∂ö„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì")
        
        dsn = f"{self.oracle_config['host']}:{self.oracle_config['port']}/{self.oracle_config['service_name']}"
        return cx_Oracle.connect(
            self.oracle_config['username'], 
            self.oracle_config['password'], 
            dsn
        )
    
    def get_oracle_products(self, limit: int = 100) -> List[Dict[str, Any]]:
        """Oracle PCS_PRODUCT_MST „Åã„ÇâË£ΩÂìÅÊÉÖÂ†±„ÇíÂèñÂæó"""
        if not self.oracle_available:
            return self._get_fallback_items_by_type('ÂÆåÊàêÂìÅ')
        
        try:
            connection = self._get_oracle_connection()
            cursor = connection.cursor()
            
            cursor.execute("""
                SELECT 
                    PRODUCT_CODE,
                    PRODUCT_NAME,
                    YARN_COMPOSITION,
                    SERIES_NAME,
                    LENGTH_M,
                    COLOR,
                    YARN_TYPE,
                    RAW_NUM,
                    PRODUCTION_NUM,
                    KNIT,
                    CORE_YARN_TYPE,
                    SPOOL_TYPE
                FROM (
                    SELECT * FROM PCS_PRODUCT_MST 
                    WHERE PRODUCT_CODE IS NOT NULL
                    AND PRODUCT_NAME IS NOT NULL
                    ORDER BY PRODUCT_CODE
                ) WHERE ROWNUM <= :limit
            """, {'limit': limit})
            
            products = []
            for row in cursor.fetchall():
                product = {
                    'item_id': row[0],  # PRODUCT_CODE
                    'item_name': row[1],  # PRODUCT_NAME
                    'item_type': 'ÂÆåÊàêÂìÅ',  # OracleË£ΩÂìÅ„ÅØÂÆåÊàêÂìÅ„Å®„Åó„Å¶Êâ±„ÅÜ
                    'unit_of_measure': 'M',
                    'yarn_composition': row[2],
                    'series_name': row[3],
                    'length_m': row[4],
                    'color': row[5],
                    'yarn_type': row[6],
                    'raw_num': row[7],
                    'production_num': row[8],
                    'knit_type': row[9],
                    'core_yarn_type': row[10],
                    'spool_type': row[11],
                    'oracle_product_code': row[0],  # OracleÈÄ£Êê∫„Éï„É©„Ç∞
                    'source': 'oracle_direct',
                    'created_at': datetime.now().isoformat(),
                    'updated_at': datetime.now().isoformat()
                }
                products.append(product)
            
            cursor.close()
            connection.close()
            
            print(f"üåê Oracle PCS_PRODUCT_MST „Åã„Çâ {len(products)}‰ª∂„ÅÆË£ΩÂìÅ„ÇíÂèñÂæó")
            return products
            
        except Exception as e:
            print(f"OracleË£ΩÂìÅÂèñÂæó„Ç®„É©„Éº: {e}")
            return self._get_fallback_items_by_type('ÂÆåÊàêÂìÅ')
    
    def get_all_items(self) -> List[Dict[str, Any]]:
        """ÂÖ®„Ç¢„Ç§„ÉÜ„É†‰∏ÄË¶ß„ÇíÂèñÂæóÔºàOracle + „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ"""
        items = []
        
        # OracleË£ΩÂìÅ„ÇíÂèñÂæó
        oracle_products = self.get_oracle_products()
        items.extend(oracle_products)
        
        # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºà„É≠„Éº„Ç´„É´DBÔºâ„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÇÇËøΩÂä†
        fallback_items = self._get_fallback_items()
        
        # Oracle‰ª•Â§ñ„ÅÆ„Ç¢„Ç§„ÉÜ„É†„Çø„Ç§„ÉóÔºàÊ¢±ÂåÖË≥áÊùê„ÄÅÊàêÂΩ¢ÂìÅÁ≠âÔºâ„ÇíËøΩÂä†
        for item in fallback_items:
            if item['item_type'] not in ['ÂÆåÊàêÂìÅ'] or not self.oracle_available:
                items.append(item)
        
        print(f"üìä Á∑è„Ç¢„Ç§„ÉÜ„É†Êï∞: {len(items)}‰ª∂ (Oracle: {len(oracle_products)}‰ª∂)")
        
        return items
    
    def get_all_items_by_type(self, item_type: str) -> List[Dict[str, Any]]:
        """ÊåáÂÆö„Åï„Çå„Åü„Çø„Ç§„Éó„ÅÆ„Ç¢„Ç§„ÉÜ„É†‰∏ÄË¶ß„ÇíÂèñÂæó"""
        if item_type == 'ÂÆåÊàêÂìÅ' and self.oracle_available:
            return self.get_oracle_products()
        else:
            return self._get_fallback_items_by_type(item_type)
    
    def get_item(self, item_id: str) -> Optional[Dict[str, Any]]:
        """ÊåáÂÆö„Ç¢„Ç§„ÉÜ„É†„ÅÆË©≥Á¥∞„ÇíÂèñÂæó"""
        # „Åæ„ÅöOracle„Åã„ÇâÊ§úÁ¥¢
        if self.oracle_available:
            try:
                connection = self._get_oracle_connection()
                cursor = connection.cursor()
                
                # Ë£ΩÂìÅ„Éû„Çπ„Çø„Åã„ÇâÊ§úÁ¥¢
                cursor.execute("""
                    SELECT 
                        PRODUCT_CODE, PRODUCT_NAME, YARN_COMPOSITION,
                        SERIES_NAME, LENGTH_M, COLOR, YARN_TYPE,
                        RAW_NUM, PRODUCTION_NUM, KNIT, CORE_YARN_TYPE, SPOOL_TYPE
                    FROM PCS_PRODUCT_MST
                    WHERE PRODUCT_CODE = :item_id
                """, {'item_id': item_id})
                
                row = cursor.fetchone()
                if row:
                    cursor.close()
                    connection.close()
                    return {
                        'item_id': row[0],
                        'item_name': row[1],
                        'item_type': 'ÂÆåÊàêÂìÅ',
                        'unit_of_measure': 'M',
                        'yarn_composition': row[2],
                        'series_name': row[3],
                        'length_m': row[4],
                        'color': row[5],
                        'yarn_type': row[6],
                        'raw_num': row[7],
                        'production_num': row[8],
                        'knit_type': row[9],
                        'core_yarn_type': row[10],
                        'spool_type': row[11],
                        'oracle_product_code': row[0],
                        'source': 'oracle_direct'
                    }
                
                cursor.close()
                connection.close()
                
            except Exception as e:
                print(f"OracleÂÄãÂà•„Ç¢„Ç§„ÉÜ„É†ÂèñÂæó„Ç®„É©„Éº: {e}")
        
        # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Åß„É≠„Éº„Ç´„É´DB„Åã„ÇâÊ§úÁ¥¢
        return self._get_fallback_item(item_id)
    
    def get_direct_components(self, parent_item_id: str) -> List[Dict[str, Any]]:
        """Áõ¥‰∏ã„ÅÆÊßãÊàêÈÉ®ÂìÅ‰∏ÄË¶ß„ÇíÂèñÂæóÔºàOracleÊé®ÂÆö + „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ"""
        # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØBOM
        fallback_bom = self._get_fallback_components(parent_item_id)
        
        # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Åå„ÅÇ„Çå„Å∞„Åù„Çå„Çí‰ΩøÁî®
        if fallback_bom:
            return fallback_bom
        
        # OracleÊé®ÂÆöBOMÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Åå„Å™„ÅÑÂ†¥ÂêàÔºâ
        return self._generate_oracle_bom_structure(parent_item_id)
    
    def get_multi_level_bom(self, parent_item_id: str, max_depth: int = 10) -> Dict[str, Any]:
        """
        Â§öÊÆµÈöéBOM„ÇíÂ±ïÈñã„Åó„Å¶ÂèñÂæó„Åó„Åæ„Åô
        
        Args:
            parent_item_id: Ë¶™„Ç¢„Ç§„ÉÜ„É†ID
            max_depth: ÊúÄÂ§ßÂ±ïÈñãÊ∑±Â∫¶
        
        Returns:
            Dict: Â§öÊÆµÈöéBOMÊßãÈÄ†
        """
        def expand_bom(item_id: str, current_depth: int = 0) -> Dict[str, Any]:
            if current_depth >= max_depth:
                return {"item": self.get_item(item_id), "components": []}
            
            item = self.get_item(item_id)
            if not item:
                return None
            
            components = []
            direct_components = self.get_direct_components(item_id)
            
            for component in direct_components:
                component_bom = expand_bom(component['item_id'], current_depth + 1)
                if component_bom:
                    component_data = {
                        "quantity": component['quantity'],
                        "usage_type": component['usage_type'],
                        "item": component_bom['item'],
                        "components": component_bom['components']
                    }
                    components.append(component_data)
            
            return {
                "item": item,
                "components": components
            }
        
        return expand_bom(parent_item_id)
    
    def get_lots_by_item(self, item_id: str, status: str = None) -> List[Dict[str, Any]]:
        """„Ç¢„Ç§„ÉÜ„É†„Å´Èñ¢ÈÄ£„Åô„Çã„É≠„ÉÉ„Éà‰∏ÄË¶ß„ÇíÂèñÂæóÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ"""
        return self._get_fallback_lots_by_item(item_id, status)
    
    def get_all_lots(self, limit: int = 100) -> List[Dict[str, Any]]:
        """ÂÖ®„É≠„ÉÉ„Éà‰∏ÄË¶ß„ÇíÂèñÂæóÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ"""
        return self._get_fallback_all_lots(limit)
    
    def get_lot(self, lot_id: str) -> Optional[Dict[str, Any]]:
        """ÊåáÂÆö„Åï„Çå„Åü„É≠„ÉÉ„Éà„ÅÆÊÉÖÂ†±„ÇíÂèñÂæóÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ"""
        return self._get_fallback_lot(lot_id)
    
    def get_lot_genealogy_tree(self, lot_id: str, direction: str = 'forward') -> Dict[str, Any]:
        """„É≠„ÉÉ„ÉàÁ≥ªÁµ±Âõ≥„ÉÑ„É™„Éº„ÇíÂèñÂæóÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ"""
        return self._get_fallback_lot_genealogy_tree(lot_id, direction)
    
    def add_lot_genealogy(self, *args, **kwargs) -> bool:
        """„É™„Éº„Éâ„Ç™„É≥„É™„Éº„É¢„Éº„Éâ: „É≠„ÉÉ„ÉàÁ≥ªÁµ±Âõ≥ËøΩÂä†„ÅØÁÑ°Âäπ"""
        print("‚ö†Ô∏è  „É™„Éº„Éâ„Ç™„É≥„É™„Éº„É¢„Éº„Éâ: „Éá„Éº„ÇøÂ§âÊõ¥„ÅØ„Åß„Åç„Åæ„Åõ„Çì")
        return False

    # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊ©üËÉΩÔºà„É≠„Éº„Ç´„É´DBÂèÇÁÖßÔºâ
    def _get_fallback_items(self) -> List[Dict[str, Any]]:
        """„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É≠„Éº„Ç´„É´DB„Åã„Çâ„Ç¢„Ç§„ÉÜ„É†‰∏ÄË¶ß„ÇíÂèñÂæó"""
        try:
            with sqlite3.connect(self.fallback_db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute("SELECT * FROM items ORDER BY item_type, item_name")
                items = []
                for row in cursor.fetchall():
                    item = dict(row)
                    if item['additional_attributes']:
                        try:
                            item['additional_attributes'] = json.loads(item['additional_attributes'])
                        except:
                            pass
                    item['source'] = 'fallback_db'
                    items.append(item)
                return items
        except Exception as e:
            print(f"„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç¢„Ç§„ÉÜ„É†ÂèñÂæó„Ç®„É©„Éº: {e}")
            return []
    
    def _get_fallback_items_by_type(self, item_type: str) -> List[Dict[str, Any]]:
        """„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É≠„Éº„Ç´„É´DB„Åã„Çâ„Çø„Ç§„ÉóÂà•„Ç¢„Ç§„ÉÜ„É†„ÇíÂèñÂæó"""
        try:
            with sqlite3.connect(self.fallback_db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute("SELECT * FROM items WHERE item_type = ? ORDER BY item_name", (item_type,))
                items = []
                for row in cursor.fetchall():
                    item = dict(row)
                    if item['additional_attributes']:
                        try:
                            item['additional_attributes'] = json.loads(item['additional_attributes'])
                        except:
                            pass
                    item['source'] = 'fallback_db'
                    items.append(item)
                return items
        except Exception as e:
            print(f"„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Çø„Ç§„ÉóÂà•„Ç¢„Ç§„ÉÜ„É†ÂèñÂæó„Ç®„É©„Éº: {e}")
            return []
    
    def _get_fallback_item(self, item_id: str) -> Optional[Dict[str, Any]]:
        """„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É≠„Éº„Ç´„É´DB„Åã„ÇâÂÄãÂà•„Ç¢„Ç§„ÉÜ„É†„ÇíÂèñÂæó"""
        try:
            with sqlite3.connect(self.fallback_db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute("SELECT * FROM items WHERE item_id = ?", (item_id,))
                row = cursor.fetchone()
                if row:
                    item = dict(row)
                    if item['additional_attributes']:
                        try:
                            item['additional_attributes'] = json.loads(item['additional_attributes'])
                        except:
                            pass
                    item['source'] = 'fallback_db'
                    return item
                return None
        except Exception as e:
            print(f"„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂÄãÂà•„Ç¢„Ç§„ÉÜ„É†ÂèñÂæó„Ç®„É©„Éº: {e}")
            return None
    
    def _get_fallback_components(self, parent_item_id: str) -> List[Dict[str, Any]]:
        """„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É≠„Éº„Ç´„É´DB„Åã„ÇâBOMÊßãÊàê„ÇíÂèñÂæó"""
        try:
            with sqlite3.connect(self.fallback_db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute("""
                    SELECT 
                        bc.quantity,
                        bc.usage_type,
                        i.*
                    FROM bom_components bc
                    JOIN items i ON bc.component_item_id = i.item_id
                    WHERE bc.parent_item_id = ?
                    ORDER BY bc.usage_type, i.item_name
                """, (parent_item_id,))
                
                components = []
                for row in cursor.fetchall():
                    component = dict(row)
                    if component['additional_attributes']:
                        try:
                            component['additional_attributes'] = json.loads(component['additional_attributes'])
                        except:
                            pass
                    component['source'] = 'fallback_db'
                    components.append(component)
                
                return components
        except Exception as e:
            print(f"„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØBOMÊßãÊàêÂèñÂæó„Ç®„É©„Éº: {e}")
            return []
    
    def _get_fallback_lots_by_item(self, item_id: str, status: str = None) -> List[Dict[str, Any]]:
        """„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É≠„Éº„Ç´„É´DB„Åã„Çâ„É≠„ÉÉ„Éà‰∏ÄË¶ß„ÇíÂèñÂæó"""
        try:
            with sqlite3.connect(self.fallback_db_path) as conn:
                conn.row_factory = sqlite3.Row
                
                sql = """
                    SELECT 
                        l.*,
                        i.item_name,
                        i.unit_of_measure,
                        i.item_type,
                        ps.process_name,
                        qg.grade_name
                    FROM lots l
                    JOIN items i ON l.item_id = i.item_id
                    JOIN process_steps ps ON l.process_code = ps.process_code
                    LEFT JOIN quality_grades qg ON l.quality_grade = qg.grade_code
                    WHERE l.item_id = ?
                """
                params = [item_id]
                
                if status:
                    sql += " AND l.lot_status = ?"
                    params.append(status)
                
                sql += " ORDER BY l.production_date DESC, l.lot_id DESC"
                
                cursor = conn.execute(sql, params)
                lots = [dict(row) for row in cursor.fetchall()]
                
                return lots
        except Exception as e:
            print(f"„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„É≠„ÉÉ„ÉàÂèñÂæó„Ç®„É©„Éº: {e}")
            return []
    
    def _get_fallback_all_lots(self, limit: int = 100) -> List[Dict[str, Any]]:
        """„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É≠„Éº„Ç´„É´DB„Åã„ÇâÂÖ®„É≠„ÉÉ„Éà‰∏ÄË¶ß„ÇíÂèñÂæó"""
        try:
            with sqlite3.connect(self.fallback_db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute("""
                    SELECT 
                        l.*,
                        i.item_name,
                        i.item_type,
                        ps.process_name,
                        qg.grade_name
                    FROM lots l
                    JOIN items i ON l.item_id = i.item_id
                    JOIN process_steps ps ON l.process_code = ps.process_code
                    LEFT JOIN quality_grades qg ON l.quality_grade = qg.grade_code
                    ORDER BY l.production_date DESC, l.lot_id DESC
                    LIMIT ?
                """, (limit,))
                
                lots = [dict(row) for row in cursor.fetchall()]
                return lots
        except Exception as e:
            print(f"„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂÖ®„É≠„ÉÉ„ÉàÂèñÂæó„Ç®„É©„Éº: {e}")
            return []
    
    def _get_fallback_lot(self, lot_id: str) -> Optional[Dict[str, Any]]:
        """„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É≠„Éº„Ç´„É´DB„Åã„Çâ„É≠„ÉÉ„ÉàË©≥Á¥∞„ÇíÂèñÂæó"""
        try:
            with sqlite3.connect(self.fallback_db_path) as conn:
                conn.row_factory = sqlite3.Row
                cursor = conn.execute("""
                    SELECT l.*, i.item_name, i.item_type, 
                           p.process_name, p.process_level,
                           q.grade_name, q.processing_rule
                    FROM lots l
                    JOIN items i ON l.item_id = i.item_id
                    JOIN process_steps p ON l.process_code = p.process_code
                    JOIN quality_grades q ON l.quality_grade = q.grade_code
                    WHERE l.lot_id = ?
                """, (lot_id,))
                
                row = cursor.fetchone()
                return dict(row) if row else None
        except Exception as e:
            print(f"„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„É≠„ÉÉ„ÉàË©≥Á¥∞ÂèñÂæó„Ç®„É©„Éº: {e}")
            return None
    
    def _get_fallback_lot_genealogy_tree(self, lot_id: str, direction: str = 'forward') -> Dict[str, Any]:
        """„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É≠„Éº„Ç´„É´DB„Åã„Çâ„É≠„ÉÉ„ÉàÁ≥ªÁµ±Âõ≥„ÉÑ„É™„Éº„ÇíÂèñÂæó"""
        try:
            def build_tree(current_lot_id: str, visited: set, depth: int = 0) -> Dict[str, Any]:
                if current_lot_id in visited or depth >= 10:  # ÁÑ°Èôê„É´„Éº„ÉóÂõûÈÅø„Å®Ê∑±Â∫¶Âà∂Èôê
                    return None
                
                visited.add(current_lot_id)
                
                with sqlite3.connect(self.fallback_db_path) as conn:
                    conn.row_factory = sqlite3.Row
                    
                    # ÁèæÂú®„ÅÆ„É≠„ÉÉ„ÉàÊÉÖÂ†±ÂèñÂæó
                    cursor = conn.execute("""
                        SELECT l.*, i.item_name, p.process_name, q.grade_name
                        FROM lots l
                        JOIN items i ON l.item_id = i.item_id
                        JOIN process_steps p ON l.process_code = p.process_code
                        LEFT JOIN quality_grades q ON l.quality_grade = q.grade_code
                        WHERE l.lot_id = ?
                    """, (current_lot_id,))
                    
                    current_lot = cursor.fetchone()
                    if not current_lot:
                        return None
                    
                    lot_data = dict(current_lot)
                    
                    # Èñ¢ÈÄ£„É≠„ÉÉ„ÉàÂèñÂæó
                    if direction == 'forward':
                        # Â≠ê„É≠„ÉÉ„ÉàÔºà„Åì„ÅÆ„É≠„ÉÉ„Éà„ÅåË¶™„Å´„Å™„Å£„Å¶„ÅÑ„Çã„ÇÇ„ÅÆÔºâ
                        cursor = conn.execute("""
                            SELECT lg.*, cl.*, ci.item_name as child_item_name, 
                                   cp.process_name as child_process_name
                            FROM lot_genealogy lg
                            JOIN lots cl ON lg.child_lot_id = cl.lot_id
                            JOIN items ci ON cl.item_id = ci.item_id
                            JOIN process_steps cp ON cl.process_code = cp.process_code
                            WHERE lg.parent_lot_id = ?
                            ORDER BY lg.created_at
                        """, (current_lot_id,))
                        
                        related_lots = cursor.fetchall()
                        children = []
                        
                        for related in related_lots:
                            child_tree = build_tree(related['child_lot_id'], visited.copy(), depth + 1)
                            if child_tree:
                                children.append(child_tree)
                        
                        lot_data['children'] = children
                    
                    else:  # backward
                        # Ë¶™„É≠„ÉÉ„ÉàÔºà„Åì„ÅÆ„É≠„ÉÉ„Éà„ÅåÂ≠ê„Å´„Å™„Å£„Å¶„ÅÑ„Çã„ÇÇ„ÅÆÔºâ
                        cursor = conn.execute("""
                            SELECT lg.*, pl.*, pi.item_name as parent_item_name,
                                   pp.process_name as parent_process_name
                            FROM lot_genealogy lg
                            JOIN lots pl ON lg.parent_lot_id = pl.lot_id
                            JOIN items pi ON pl.item_id = pi.item_id
                            JOIN process_steps pp ON pl.process_code = pp.process_code
                            WHERE lg.child_lot_id = ?
                            ORDER BY lg.created_at
                        """, (current_lot_id,))
                        
                        related_lots = cursor.fetchall()
                        parents = []
                        
                        for related in related_lots:
                            parent_tree = build_tree(related['parent_lot_id'], visited.copy(), depth + 1)
                            if parent_tree:
                                parents.append(parent_tree)
                        
                        lot_data['parents'] = parents
                    
                    return lot_data
            
            return build_tree(lot_id, set())
            
        except Exception as e:
            print(f"„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„É≠„ÉÉ„ÉàÁ≥ªÁµ±Âõ≥ÂèñÂæó„Ç®„É©„Éº: {e}")
            return {}
    
    # „É™„Éº„Éâ„Ç™„É≥„É™„Éº„É°„ÇΩ„ÉÉ„ÉâÔºàÂ§âÊõ¥Êìç‰Ωú„ÅØÁÑ°ÂäπÂåñÔºâ
    def add_item(self, *args, **kwargs) -> bool:
        """„É™„Éº„Éâ„Ç™„É≥„É™„Éº„É¢„Éº„Éâ: „Ç¢„Ç§„ÉÜ„É†ËøΩÂä†„ÅØÁÑ°Âäπ"""
        print("‚ö†Ô∏è  „É™„Éº„Éâ„Ç™„É≥„É™„Éº„É¢„Éº„Éâ: „Éá„Éº„ÇøÂ§âÊõ¥„ÅØ„Åß„Åç„Åæ„Åõ„Çì")
        return False
    
    def add_bom_component(self, *args, **kwargs) -> bool:
        """„É™„Éº„Éâ„Ç™„É≥„É™„Éº„É¢„Éº„Éâ: BOMËøΩÂä†„ÅØÁÑ°Âäπ"""
        print("‚ö†Ô∏è  „É™„Éº„Éâ„Ç™„É≥„É™„Éº„É¢„Éº„Éâ: „Éá„Éº„ÇøÂ§âÊõ¥„ÅØ„Åß„Åç„Åæ„Åõ„Çì")
        return False
    
    def create_lot(self, *args, **kwargs) -> str:
        """„É™„Éº„Éâ„Ç™„É≥„É™„Éº„É¢„Éº„Éâ: „É≠„ÉÉ„Éà‰ΩúÊàê„ÅØÁÑ°Âäπ"""
        print("‚ö†Ô∏è  „É™„Éº„Éâ„Ç™„É≥„É™„Éº„É¢„Éº„Éâ: „Éá„Éº„ÇøÂ§âÊõ¥„ÅØ„Åß„Åç„Åæ„Åõ„Çì")
        return None

    def _generate_oracle_bom_structure(self, item_id: str) -> List[Dict[str, Any]]:
        """OracleÂÆü„Éá„Éº„Çø„Å´Âü∫„Å•„ÅèBOMÊßãÊàê„ÇíÁîüÊàêÔºàÊé®ÂÆöÔºâ"""
        item = self.get_item(item_id)
        if not item:
            print(f"üîó OracleÊé®ÂÆöBOM {item_id}: „Ç¢„Ç§„ÉÜ„É†ÊÉÖÂ†±„Å™„Åó")
            return []
        
        bom_components = []
        
        if item['item_type'] == 'ÂÆåÊàêÂìÅ' and item.get('source') == 'oracle_direct':
            # OracleÂÆåÊàêÂìÅ„ÅÆÂ†¥Âêà„ÄÅÂÆü„Éá„Éº„Çø„Éë„Çø„Éº„É≥„Å´Âü∫„Å•„ÅèÊé®ÂÆöBOM
            item_name = item.get('item_name', '')
            
            # PE„É©„Ç§„É≥Ôºà„Éñ„É¨„Ç§„Éá„ÉÉ„ÉâÔºâ„ÅÆÂ†¥Âêà
            if 'PE' in item_name or '„Éñ„É¨„Ç§„Éá„ÉÉ„Éâ' in item_name or 'VARIVAS' in item_name:
                # PEÂéüÁ≥∏
                pe_raw = {
                    'item_id': 'PE-UHMW-001',
                    'item_name': 'PEË∂ÖÈ´òÂàÜÂ≠êÈáèÂéüÁ≥∏',
                    'item_type': 'ÂéüÁ≥∏',
                    'unit_of_measure': 'KG',
                    'quantity': round(float(item.get('length_m', 150)) * 0.001, 3),  # Èï∑„Åï„Åã„ÇâÈáçÈáèÊé®ÂÆö
                    'usage_type': 'Main Material',
                    'source': 'oracle_estimated'
                }
                bom_components.append(pe_raw)
                
                # ÊüìÊñôÔºà5Ëâ≤„Éû„Éº„Ç≠„É≥„Ç∞„ÅÆÂ†¥ÂêàÔºâ
                if '5Ëâ≤' in item_name or '„Éû„Éº„Ç≠„É≥„Ç∞' in item_name:
                    for i, color in enumerate(['Èùí', 'Á∑ë', 'Ëµ§', 'ÈªÑ', 'ÁôΩ'], 1):
                        dye = {
                            'item_id': f'DYE-{color[:2].upper()}-001',
                            'item_name': f'Èá£„ÇäÁ≥∏Áî®ÊüìÊñô {color}',
                            'item_type': 'Ë£úÂä©ÊùêÊñô',
                            'unit_of_measure': 'ML',
                            'quantity': 5.0,
                            'usage_type': 'Dyeing Material',
                            'source': 'oracle_estimated'
                        }
                        bom_components.append(dye)
                
                # „Çπ„Éó„Éº„É´
                spool_size = "150" if "150m" in item_name else "200"
                spool = {
                    'item_id': f'PKG-SPOOL-{spool_size}',
                    'item_name': f'„Çπ„Éó„Éº„É´ {spool_size}mÁî®',
                    'item_type': 'ÊàêÂΩ¢ÂìÅ',
                    'unit_of_measure': 'ÂÄã',
                    'quantity': 1.0,
                    'usage_type': 'Container',
                    'source': 'oracle_estimated'
                }
                bom_components.append(spool)
                
                # „É©„Éô„É´
                label = {
                    'item_id': 'PKG-LABEL-BRAID',
                    'item_name': 'PE„É©„Ç§„É≥Áî®„É©„Éô„É´',
                    'item_type': 'Ê¢±ÂåÖË≥áÊùê',
                    'unit_of_measure': 'ÂÄã',
                    'quantity': 1.0,
                    'usage_type': 'Packaging',
                    'source': 'oracle_estimated'
                }
                bom_components.append(label)
            
            # „Éä„Ç§„É≠„É≥„É©„Ç§„É≥„Éª„Éï„É≠„É≠„Ç´„Éº„Éú„É≥„É©„Ç§„É≥ÂÖ±ÈÄöÂá¶ÁêÜ
            elif '„Éä„Ç§„É≠„É≥' in item_name or '„Éï„É≠„É≠' in item_name or 'NY' in item_name or 'FC' in item_name:
                # ÂéüÁ≥∏Ôºà„Éä„Ç§„É≠„É≥„Åæ„Åü„ÅØ„Éï„É≠„É≠„Ç´„Éº„Éú„É≥Ôºâ
                raw_material = 'NY6-RAW-001' if '„Éä„Ç§„É≠„É≥' in item_name or 'NY' in item_name else 'FC-PVDF-001'
                raw_name = '„Éä„Ç§„É≠„É≥6ÂéüÁ≥∏' if '„Éä„Ç§„É≠„É≥' in item_name else '„Éï„É≠„É≠„Ç´„Éº„Éú„É≥ÂéüÁ≥∏'
                
                raw = {
                    'item_id': raw_material,
                    'item_name': raw_name,
                    'item_type': 'ÂéüÁ≥∏',
                    'unit_of_measure': 'KG',
                    'quantity': round(float(item.get('length_m', 150)) * 0.0008, 3),
                    'usage_type': 'Main Material',
                    'source': 'oracle_estimated'
                }
                bom_components.append(raw)
                
                # ÊüìÊñô
                if 'ÈÄèÊòé' not in item_name:
                    dye = {
                        'item_id': 'DYE-CLR-001',
                        'item_name': 'Èá£„ÇäÁ≥∏Áî®ÊüìÊñô ÈÄèÊòé',
                        'item_type': 'Ë£úÂä©ÊùêÊñô',
                        'unit_of_measure': 'ML',
                        'quantity': 3.0,
                        'usage_type': 'Dyeing Material',
                        'source': 'oracle_estimated'
                    }
                    bom_components.append(dye)
                
                # „Çπ„Éó„Éº„É´
                spool_size = "150" if "150m" in item_name else "200"
                spool = {
                    'item_id': f'PKG-SPOOL-{spool_size}',
                    'item_name': f'„Çπ„Éó„Éº„É´ {spool_size}mÁî®',
                    'item_type': 'ÊàêÂΩ¢ÂìÅ',
                    'unit_of_measure': 'ÂÄã',
                    'quantity': 1.0,
                    'usage_type': 'Container',
                    'source': 'oracle_estimated'
                }
                bom_components.append(spool)
            
            # Ê±éÁî®Ê¢±ÂåÖÊùêÊñôÔºàÂÖ®Ë£ΩÂìÅÂÖ±ÈÄöÔºâ
            if not bom_components:  # ‰ªñ„ÅÆ„Éë„Çø„Éº„É≥„Å´„Éû„ÉÉ„ÉÅ„Åó„Å™„Åã„Å£„ÅüÂ†¥Âêà
                # Âü∫Êú¨ÁöÑ„Å™Ê¢±ÂåÖÊùêÊñô„ÇíËøΩÂä†
                basic_package = {
                    'item_id': 'PKG-BASIC-001',
                    'item_name': 'Âü∫Êú¨Ê¢±ÂåÖÊùêÊñô„Çª„ÉÉ„Éà',
                    'item_type': 'Ê¢±ÂåÖË≥áÊùê',
                    'unit_of_measure': 'ÂÄã',
                    'quantity': 1.0,
                    'usage_type': 'Packaging',
                    'source': 'oracle_estimated'
                }
                bom_components.append(basic_package)
        
        print(f"üîó OracleÊé®ÂÆöBOM {item_id}: {len(bom_components)}‰ª∂ÁîüÊàê")
        return bom_components


# ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅ„ÅÆÈñ¢Êï∞
def create_oracle_bom_manager() -> OracleBOMManager:
    """Oracle BOMÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí‰ΩúÊàê"""
    return OracleBOMManager()


if __name__ == "__main__":
    # „ÉÜ„Çπ„ÉàÂÆüË°å
    print("üåê Oracle BOMÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É† „ÉÜ„Çπ„ÉàÈñãÂßã")
    print("=" * 50)
    
    oracle_bom = create_oracle_bom_manager()
    
    # OracleË£ΩÂìÅÂèñÂæó„ÉÜ„Çπ„Éà
    products = oracle_bom.get_oracle_products(limit=5)
    print(f"\nüì¶ OracleË£ΩÂìÅ„Çµ„É≥„Éó„É´: {len(products)}‰ª∂")
    for product in products[:3]:
        print(f"  ‚Ä¢ {product['item_id']}: {product['item_name']}")
    
    # ÂÖ®„Ç¢„Ç§„ÉÜ„É†ÂèñÂæó„ÉÜ„Çπ„Éà
    all_items = oracle_bom.get_all_items()
    print(f"\nüìä Á∑è„Ç¢„Ç§„ÉÜ„É†Êï∞: {len(all_items)}‰ª∂")
    
    print("\n‚úÖ Oracle BOMÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É† „ÉÜ„Çπ„ÉàÂÆå‰∫Ü") 